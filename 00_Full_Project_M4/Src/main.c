/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 */

#include "../Inc/hal_gpio.h"
#include "../Inc/hal_uart.h"
#include "../Inc/hal_systick.h"
#include "../Inc/hal_dma.h"
#include "../Inc/hal_i2c.h"
#include "../Inc/hal_adc.h"
#include "main.h"

#include <../Inc/peripherals.h>
#include <../Inc/typedefs.h>
#include <../Inc/memorymap.h>
#include "stdint.h"

/*********************************************************************************************************************************
 * Interrupt Handlers
 *********************************************************************************************************************************/
uint16_t dataADC = 0;
void SysTick_Handler(void)
{
	// SysTick only set PendSV flag, so systick remains deterministic
	Hal_vEnableDMA();
	uint32_t* prData = Hal_DMA1_vGetTransmitData();
	int j = 0;
	for (int i = 0; i < 10; i++)
	{
		SSD1306_vWriteDisplay(0, i, prData[j]);
		j++;
	}
    dataADC = Hal_ADC_u16ReadChannel();
    if (dataADC != 0)
    {
        Hal_GPIO_vOutputToggle(5, GPIO_A);  // Your action
    }
}

// 3) Your IRQ handler in the same C file (or in stm32f3xx_it.c)
void EXTI15_10_IRQHandler(void)
{
    if (EXTI->PR1 & (1U << 13))  // Check if EXTI13 triggered
    {
        EXTI->PR1 |= (1U << 13);  // Clear pending bit by writing 1
        Hal_DMA1_vCorruptData();
        Hal_GPIO_vOutputToggle(5, GPIO_A);  // Your action
    }

}

/*********************************************************************************************************************************
 * Main Function
 *********************************************************************************************************************************/

int main(void)
{
	// Activate all system clocks which are needed
	hal_vEnableRCCclock();

	// Activate all GPIOs needed
	Main_vSetupGPIOs();

	/***************************************************
	 * Activate all the peripherals:
	 * 	- USART3
	 * 	- DMA1
	 * 	- I2C1
	 ***************************************************/

	// USART3 Init
	Hal_USART3_vInit();

	// DMA1 Init
	Hal_DMA1_vInit();

	// I2C Init
    Hal_I2C_vInitMaster(OLED);

    // OLED SSD Init
    SSD1306_vInit();

    Hal_ADC_vInit();
    Hal_ADC_vStart();

	/***************************************************
	 * Initial functions
	 ***************************************************/

    // Reset Display
    SSD1306_vResetDisplay();

	/***************************************************
	 * Activate the interrupts (system and peripherals)
	 ***************************************************/

    Hal_ButtonInterrupt_vInit();

	Hal_SysTick_vInit();


    while(1)
    {

    }
}

/*********************************************************************************************************************************
 * Main Functions
 *********************************************************************************************************************************/

void Main_vSetupGPIOs(void)
{
	// Activate button at PC13
	Config_vSetupGPIO(13, GPIO_INPUT, GPIO_PUSHPULL, GPIO_PULLUP, GPIO_C);

	// Set LED at GPIOA on Pin5 to output
	Config_vSetupGPIO(5, GPIO_OUTPUT, GPIO_PUSHPULL, GPIO_PULLUP, GPIO_A);

	// Activate PB9 for USART3 Tx
	GPIOB->MODER &= ~(3U << 18);
	GPIOB->MODER |= (1U << 19);
	GPIOB->OTYPER &= ~(1U << 9);
	GPIOB->PUPDR &= ~(3U << 18);
	GPIOB->OSPEEDR &= ~(3U << 18);
    GPIOB->AFRH &= ~(0xF << 4);  // Clear AFR for PB9
    GPIOB->AFRH |=  (0x7 << 4);  // AF7 = USART3

	/* Using PB6 SCL and PB7 SDA, because the other ones interfere with debug */
	GPIOB->MODER &= ~(0x3 << 12);
	GPIOB->MODER |= (1U << 13);
	GPIOB->OTYPER &= ~(0x1 << 6);
	GPIOB->PUPDR &= ~(0x3 << 12);
	GPIOB->OSPEEDR &= ~(0x3 << 12);
    GPIOB->AFRL	&= ~(0xF << 24);  // Clear AF4 for PB6
    GPIOB->AFRL |=  (0x4 << 24);  // AF4 = I2C1 SDA

	GPIOB->MODER &= ~(0x3 << 14);
	GPIOB->MODER |= (1U << 15);
	GPIOB->OTYPER &= ~(0x1 << 7);
	GPIOB->PUPDR &= ~(0x3 << 14);
	GPIOB->OSPEEDR &= ~(0x3 << 14);
    GPIOB->AFRL	&= ~(0xF << 28);  // Clear AF4 for PB7
    GPIOB->AFRL |=  (0x4 << 28);  // AF4 = I2C1 SDA

    // Activate PA0 for the ADC as Analog input
	GPIOA->MODER &= ~(0x3 << 0);
	GPIOA->MODER |= (0x3 << 0);
	GPIOA->OTYPER &= ~(0x1 << 0);
	GPIOA->PUPDR &= ~(0x3 << 0);
	GPIOA->OSPEEDR &= ~(0x3 << 0);
}
